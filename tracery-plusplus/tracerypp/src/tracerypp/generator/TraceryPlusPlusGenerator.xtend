/*
 * generated by Xtext 2.30.0
 */
package tracerypp.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import tracerypp.traceryPlusPlus.TraceryPlusPlusProgram
import tracerypp.traceryPlusPlus.ListDeclaration
import tracerypp.traceryPlusPlus.Word
import tracerypp.traceryPlusPlus.ObjectAttribute
import tracerypp.traceryPlusPlus.ObjectDeclaration
import java.util.List
import tracerypp.traceryPlusPlus.Statement
import tracerypp.traceryPlusPlus.Attribute
import tracerypp.traceryPlusPlus.NameExistingListAttribute
import tracerypp.traceryPlusPlus.NameValueAttribute
import tracerypp.traceryPlusPlus.Pronouns
import tracerypp.traceryPlusPlus.Variable
import tracerypp.traceryPlusPlus.ListUse
import tracerypp.traceryPlusPlus.ObjectUse
import tracerypp.traceryPlusPlus.ObjectPronoun
import tracerypp.traceryPlusPlus.SubstoryDeclaration
import tracerypp.traceryPlusPlus.Story
import tracerypp.traceryPlusPlus.SubstoryUse

/**
 * Generates code from your model files on save. d
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 * 
 * Author: Vakaris Paulavicius
 * Version 1.0
 */
 
class TraceryPlusPlusGenerator extends AbstractGenerator {

	// File generation method
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var model = resource.contents.head as TraceryPlusPlusProgram
		fsa.generateFile(deriveTargetFilenameFor(model, resource), model.generate)
	}
	
	// Specify the generated file name	
	def deriveTargetFilenameFor(TraceryPlusPlusProgram program, Resource resource) {
		// TraceryPlusPlusProgram and Resource are imported for future use
		return 'translated_tracerypp_grammar.json'
	}
	
	
	// Generate the content of the file
	def CharSequence generate(TraceryPlusPlusProgram program) {
		if (program.story === null) {
			return '''
				{
					"warning": "To get Tracery code, create the Story element"
				}
			'''
		}
		
		var substoryObjectInitialisations = getSubstoryObjectDeclarations(program.statements)
		var storyObjectInitialisations = getStoryObjectDeclarations(program.story, program.statements)
		
		var allObjectNames = getObjectNames(substoryObjectInitialisations)
		allObjectNames.addAll(getObjectNames(storyObjectInitialisations))
		// A JSON object
		return '''
			{
				«FOR listDeclaration : program.statements.filter(Variable).filter(ListDeclaration)»«generateJsonListDeclaration(listDeclaration) + '\n'»«ENDFOR /* Add list declarations first*/»
				«FOR initSubObj : substoryObjectInitialisations »«initSubObj + '\n'»«ENDFOR /* Add all substory object declarations */»
				«FOR initStoryObj : storyObjectInitialisations »«initStoryObj + '\n'»«ENDFOR /* Add all story object declarations */»
				«FOR substory : program.statements.filter(Variable).filter(SubstoryDeclaration) »"«substory.name.toString()»": ["«  substory.story.map[generateJsonStoryEntry(substory.name.toString())].join("")»"],«'\n'»«ENDFOR /* Add all substory elements */»
				"story": ["«program.story.story.map[generateJsonStoryEntry("story")].join("") /* Define the main story element */»"],
				"origin": ["#«FOR entry : allObjectNames »[#«entry»#]«ENDFOR /* Inside origin all the objects are initialised and the main story element is called */»story#"]
			}
		'''
	}
	
	// Shorten a list of object declaration strings 
	def getObjectNames(List<String> declarations) {
		var strings = newArrayList
		for(dec : declarations) {
			var name = dec.split(":").get(0)
			
			var start = name.indexOf("\"") + 1;
			var end = name.indexOf("\"", start);
			
			strings.add(name.substring(start, end))
		}
		return strings
	}
	
	// Get lists with attributes
	def generateJsonListDeclaration(ListDeclaration listDeclaration) {
		return '''"«listDeclaration.name»": [« FOR word : listDeclaration.list.words SEPARATOR ', ' »"« word.value »"« ENDFOR »],'''
	}
	
	// Get the definition of a substory for the JSON
	def getSubstoryObjectDeclarations(List<Statement> statements) {
		var substories = statements.filter(Variable).filter(SubstoryDeclaration)
    	val strings = newArrayList
		
		for(substory : substories) {
			var objects = substory.story.filter(ObjectUse)
			var alreadyInitialisedObjects = newArrayList
			
			for(objectUse : objects) {
				val object = objectUse.object
				val objectName = object.name.toString()
				// Find the relevant object declaration. It is easier to work that way
				val objectDeclarations = statements.filter(Variable).filter(ObjectDeclaration)
				val rightObjectDeclaration = findTheRightObjectDeclaration(objectDeclarations, objectName)
				
				if(rightObjectDeclaration !== null && !alreadyInitialisedObjects.contains(rightObjectDeclaration)) {
					val setter = "set" + objectName.substring(0, 1).toUpperCase() + objectName.substring(1) + "-" + substory.name
					val pronouns = matchPronouns(rightObjectDeclaration.pronouns, objectName, substory.name)
					strings.add('''"«setter»": ["« FOR attribute : rightObjectDeclaration.attributes.attributes »« getStringForAttribute(attribute, objectName, substory.name) »« ENDFOR »«pronouns»"],''')
					alreadyInitialisedObjects.add(rightObjectDeclaration)
				}
			}
		}
		return strings
	}
	
	// Loop through all the existing ObjectDeclaratios and return reference to that ObjectDeclaration that mathces the provided name
	def findTheRightObjectDeclaration(Iterable<ObjectDeclaration> objectDeclarations, String name) {
		for(objDeclaration : objectDeclarations) {
			if(objDeclaration.name.toString() == name) {
				return objDeclaration
			}
		}
		return null
	}
	
	
	// Get string representation to use for an attribute when defining the JSON object
	def getStringForAttribute(Attribute attribute, String objectName, String storyname) {
    	if (attribute instanceof NameValueAttribute) {
    		// Example: hero has attributes - name = "John
    		// This will give ---> [heroName:John]
    		val variableName = attribute.name
    		return '''[«objectName + variableName.substring(0, 1).toUpperCase() + variableName.substring(1) + "-" + storyname»:«attribute.value.value»]'''
    	}
    	else if(attribute instanceof NameExistingListAttribute) {
    		// Example: hero has attributes - name = princeNames
    		// This will give ---> [heroName:#princeNames#]
    		val variableName = attribute.name
    		val list = attribute.value
    		return '''[«objectName + variableName.substring(0, 1).toUpperCase() + variableName.substring(1) + "-" + storyname»:#«list.name»#]'''
    	}
//    	else if(attribute instanceof JustNameAttribute) {
//    		// Example: hero has attributes - occupation
//    		// This will give ---> [heroOccupation:#occupation#]
//    		val variableName = attribute.name.name
//    		return '''[«objectName + variableName.substring(0, 1).toUpperCase() + variableName.substring(1)»:#«variableName»#]'''
//    	}
    	else {
    		// This place should never be reached
    		return ''''''
    	}
	}
	
	/*
	 *	Get a list of variable declarations for the main story part
	 */
	def getStoryObjectDeclarations(Story story, List<Statement> statements) {
		var strings = newArrayList
		var objects = story.story.filter(ObjectUse)
		var alreadyInitialisedObjects = newArrayList
		
			for(objectUse : objects) {
				val object = objectUse.object
				val objectName = object.name.toString()
				// Find the relevant object declaration. It is easier to work that way
				val objectDeclarations = statements.filter(Variable).filter(ObjectDeclaration)
				val rightObjectDeclaration = findTheRightObjectDeclaration(objectDeclarations, objectName)
				
				if(rightObjectDeclaration !== null && !alreadyInitialisedObjects.contains(rightObjectDeclaration)) {
					val setter = "set" + objectName.substring(0, 1).toUpperCase() + objectName.substring(1) + "-story"
					val pronouns = matchPronouns(rightObjectDeclaration.pronouns, objectName, "story")
					strings.add('''"«setter»": ["« FOR attribute : rightObjectDeclaration.attributes.attributes »« getStringForAttribute(attribute, objectName, "story") »« ENDFOR »«pronouns»"],''')
					alreadyInitialisedObjects.add(rightObjectDeclaration)
				}
			}
		return strings
	}
	
	
	/* DISPATCH */
	
		
	// Retrieve the right reference to call the right object
	dispatch def generateJsonStoryEntry(ObjectUse object, String storyname) {
		val objectName = object.object.name
		if(object instanceof ObjectAttribute) {
			val attribute = getAttributeName(object.attribute)
			return '''#«objectName + attribute.substring(0, 1).toUpperCase() + attribute.substring(1) + "-" + storyname»« FOR mod : object.modifiers.modifiers »« '.' + mod.toString().substring(1)   »« ENDFOR »#'''
		}
		else if(object instanceof ObjectPronoun) {
			val attribute = object.pronoun.toString().substring(1)
			return '''#«objectName + attribute.substring(0, 1).toUpperCase() + attribute.substring(1) + "-" + storyname»#'''
		}
		
	}	
	
	// Retrieve the plain string value
	dispatch def generateJsonStoryEntry(Word word, String storyname) {
		return '''«word.value»'''
	}

	
	// Generates reference to list and adds specified modifiers
	dispatch def generateJsonStoryEntry(ListUse storyVariable, String storyname) {
		return '''#«storyVariable.variable.name»« FOR mod : storyVariable.modifiers.modifiers »« '.' + mod.toString().substring(1) »« ENDFOR »#'''
	}
	
	// Generates reference to the substroy use
	dispatch def generateJsonStoryEntry(SubstoryUse storyVariable, String storyname) {
		return '''#«storyVariable.variable.name»#'''
	}
	
	
	
	
	
	/* 
	 *      ADDITIONAL HELPER METHODS
	 */
	
	// Was used when different attribute representations contained names at different places
	def getAttributeName(Attribute attribute) {
    	if(attribute instanceof NameExistingListAttribute) {
    		return attribute.name
    	}
    	else if(attribute instanceof NameValueAttribute) {
    		return attribute.name
    	}
//    	else if (attribute instanceof JustNameAttribute) {
//    		return attribute.pointer.name
//    	}
	}
	
	// Method to match the pronouns
	def matchPronouns(Pronouns pronouns, String name, String storyname) {
		val value = pronouns.value
		if (value == "He") {
			return "[" + name + "They-" + storyname + ":he][" + name + "Them-" + storyname + ":him][" + name + "Their-" + storyname + ":his][" + name + "Theirs-" + storyname + ":his]"
		}
		else if (value == "She") {
			return "[" + name + "They-" + storyname + ":she][" + name + "Them-" + storyname + ":her][" + name + "Their-" + storyname + ":her][" + name + "Theirs-" + storyname + ":hers]"
		}
		else if (value == "It") {
			return "[" + name + "They-" + storyname + ":it][" + name + "Them-" + storyname + ":it][" + name + "Their-" + storyname + ":its][" + name + "Theirs-" + storyname + ":its]"
		}
		else if (value == "They") {
			return "[" + name + "They-" + storyname + ":they][" + name + "Them-" + storyname + ":them][" + name + "Their-" + storyname + ":their][" + name + "Theirs-" + storyname + ":theirs]"
		}
		else {
			return "unknown"
		}
	}
	
}
