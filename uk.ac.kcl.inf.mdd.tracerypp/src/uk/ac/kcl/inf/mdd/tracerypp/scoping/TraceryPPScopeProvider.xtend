/*
 * generated by Xtext 2.29.0
 */
package uk.ac.kcl.inf.mdd.tracerypp.scoping

import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.IScope
import uk.ac.kcl.inf.mdd.tracerypp.traceryPP.ObjectAttribute
import org.eclipse.emf.ecore.EReference

import static extension org.eclipse.xtext.EcoreUtil2.*
import uk.ac.kcl.inf.mdd.tracerypp.traceryPP.Story
import uk.ac.kcl.inf.mdd.tracerypp.traceryPP.Model

import static org.eclipse.xtext.scoping.Scopes.*
import org.eclipse.emf.ecore.EObject

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class TraceryPPScopeProvider extends AbstractDeclarativeScopeProvider {
	
//          A TRY TO FIX SCOPING ISSUES	
// 	
//	def IScope scope_ObjectAttribute_attribute(ObjectAttribute context, EReference ref) {
//		val containingStory = context.getContainerOfType(Story)
//		
//		if (containingStory !== null) {
//			containingStory.visibleVariablesScope
//		}
//		else {
//			val containingProgram = context.getContainerOfType(Model)
//			scopeFor(containingProgram.statements.filter(Story))
//		}
//	}
//	
//	def IScope visibleVariablesScope(EObject context) {
//		if (context instanceof Story) {
//			scopeFor(context.story.filter(ObjectAttribute), context.eContainer.visibleVariablesScope)
//		}
//		else if (context instanceof Model) {
//			scopeFor(context.statements.filter(Story))
//		}
//	}
}
